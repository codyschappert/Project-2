from PyQt6.QtWidgets import *
from gui import *
import re
import csv

user_info = {}
csv_file = "accounts.csv"

def load_user_info_from_csvfile() -> None:
    """Loads all users and user info into user_info dict from a csv file."""
    try:
        with open(csv_file, mode='r', newline='') as csvfile:
            reader = csv.DictReader(csvfile)

            for row in reader:
                username = row['username']
                password = row['password']

                checking = float(row['checking'])
                savings = float(row['savings'])

                user_info[username] = {
                    'password': password,
                    'checking': Account("Checking", checking),
                    'savings': Account("Savings", savings)
                }

    except FileNotFoundError:
        pass # This whole function is non-essential because of no existing user database exists, the whole program can still function.

def save_users_to_csvfile() -> None:
    """Saves all usernames, password, and account info from user_info dict into a csv file."""
    with open(csv_file, mode='w', newline='') as csvfile:
        fieldnames = ['username', 'password', 'checking', 'savings']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        writer.writeheader()

        for username, data in user_info.items():
            writer.writerow({
                'username': username,
                'password': data['password'],
                'checking': data['checking'].get_balance(),
                'savings': data['savings'].get_balance()
            })

class Launch(QMainWindow, Ui_LaunchWindow):
    """Initializes the launch window."""
    def __init__(self: Launch) -> None:
        super().__init__()
        self.setupUi(self)
        self.create_account = CreateAccount(self)
        self.details = Details(self)

        self.signin_button.clicked.connect(lambda: self.signin())
        self.createaccount_button.clicked.connect(lambda: self.create_account_window())

    def signin(self: Launch) -> None:
        """Checks inputted username and password against user_info dict when sign in button is clicked."""
        username = self.username_input.text()
        password = self.password_input.text()

        try:
            if user_info[username]['password'] == password:
                self.details.set_user(username) # Communicates to details window which user is logged in
                self.hide()
                self.details.show()

                self.username_input.clear()
                self.password_input.clear()

            elif user_info[username] != password:
                raise ValueError

        except KeyError:
            self.error_label.setText("No such user!")
            self.username_input.clear()
            self.password_input.clear()

        except ValueError:
            self.error_label.setText("Incorrect Password!")
            self.password_input.clear()

    def create_account_window(self: Launch) -> None:
        """Shows the account creation window when create account button is clicked."""
        self.hide()
        self.create_account.show()


class CreateAccount(QMainWindow, Ui_AccountCreationWindow):
    def __init__(self: CreateAccount, launch_window: Launch) -> None:
        """Initializes the account creation window."""
        super().__init__()
        self.setupUi(self)
        self.launch_window = launch_window

        self.create_account_button.clicked.connect(lambda: self.create_account())
        self.back_button.clicked.connect(lambda: self.back())

    def create_account(self: CreateAccount) -> None:
        """Stores new account data to user_info after input is handled."""
        username = self.username_input.text()
        password = self.password_input.text()
        password_confirm = self.password_confirm_input.text()

        try:
            if not bool(re.fullmatch(r'\w+', username)):
                raise ValueError('Username may only contain letters, numbers, and underscores.')

            elif not bool(re.fullmatch(r'\w+', password)):
                raise ValueError('Password may only contain letters, numbers, and underscores.')

            # Lines 109-113 were generated by AI (not disclosed in project meeting because I had not known I was going to use it)
            # because I could not think of an effective character validation method on my own.

            if not username:
                raise ValueError('Please enter a username.')

            elif username in user_info:
                raise ValueError('Account already exists.')

            elif not password:
                raise ValueError('Please enter a password.')

            elif password != password_confirm:
                raise ValueError('Passwords do not match.')

        except ValueError as e:
            self.username_input.clear()
            self.password_input.clear()
            self.password_confirm_input.clear()
            self.error_label.setText(f"{e}")

        else:
            user_info[username] = {  # Sets user account details properly
                'password': password,
                'checking': Account('Checking', 0),
                'savings': Account('Savings', 0)
            }

            self.error_label.setText("Account created!")
            save_users_to_csvfile()

            self.username_input.clear()
            self.password_input.clear()
            self.password_confirm_input.clear()

    def back(self: CreateAccount) -> None:
        """Resets the account creation window and returns to launch window when back button is clicked."""
        self.error_label.setText("Please create an account.")
        self.hide()

        self.launch_window.error_label.setText("Please log in or create an account.")
        self.launch_window.show()


class Details(QMainWindow, Ui_BankDetailsWindow):
    def __init__(self: Details, launch_window: Launch) -> None:
        """Initializes the account details window."""
        super().__init__()
        self.setupUi(self)
        self.launch_window = launch_window

        self.user = None  # stores username
        self.accounts = None  # stores account data in user's dict

        self.checking_option_confirm.clicked.connect(lambda: self.confirm('checking'))
        self.savings_option_confirm.clicked.connect(lambda: self.confirm('savings'))
        self.sign_out_button.clicked.connect(lambda: self.sign_out())

    def set_user(self: Details, username: str) -> None:
        """Load's correct details for the logged-in user."""
        self.user = username
        self.accounts = user_info[username]
        self.checking_balance_label.setText(f"{self.accounts['checking'].get_balance():.2f}") # Sets checking balance on log in
        self.savings_balance_label.setText(f"{self.accounts['savings'].get_balance():.2f}") # Sets savings balance on login

    def confirm(self: Details, account_type: str) -> None:
        """Deposits/Withdraws to/from account_type."""
        account = self.accounts[account_type] # initializes the object (account) from the dict info

        if account_type == 'checking':
            balance_label = self.checking_balance_label
            amount_input = self.checking_amount_input
            option_select = self.checking_option_select
            error_label = self.bank_error_label

        elif account_type == 'savings':
            balance_label = self.savings_balance_label
            amount_input = self.savings_amount_input
            option_select = self.savings_option_select
            error_label = self.bank_error_label

        try:                                                        # I'm really not sure why pycharm freaks out with all the upcoming variable names, especially because
            amount = float(amount_input.text())                     # everything works flawlessly, but this is the most efficient option out of everything I tried
            if amount <= 0:                                         # because everything else had a lot of repeated code.
                raise TypeError('Please enter a positive number')

        except TypeError as e:
            error_label.setText(f"{e}")
            amount_input.clear()

        except ValueError:
            error_label.setText("Please enter a number.")
            amount_input.clear()

        else:
            option = option_select.currentText()

            if option == 'Deposit':
                account.deposit(amount)
                balance_label.setText(f"{account.get_balance():.2f}")
                error_label.setText("")
                save_users_to_csvfile()

            elif option == 'Withdraw':
                if account.withdraw(amount):
                    balance_label.setText(f"{account.get_balance():.2f}")
                    save_users_to_csvfile()
                else:
                    error_label.setText("Insufficient funds. Please deposit money or withdraw a smaller amount.")

    def sign_out(self: Details) -> None:
        """Resets all user inputs to original states and hides window when sign out button is clicked."""
        self.checking_amount_input.clear()
        self.checking_option_select.setCurrentIndex(0)

        self.savings_amount_input.clear()
        self.savings_option_select.setCurrentIndex(0)

        self.bank_error_label.clear()
        self.launch_window.error_label.setText("Please log in or create an account.")

        self.hide()
        self.launch_window.show()

class Account:
    def __init__(self: Account, name: str, balance: float = 0.00) -> None:
        """Initializes the account object."""
        self.__name = name
        self.set_balance(balance)

    def deposit(self: Account, amount: float) -> bool:
        """Deposits amount."""
        if amount <= 0:
            return False
        else:
            self.__balance += amount
            return True

    def withdraw(self: Account, amount: float) -> bool:
        """Withdraws amount."""
        if amount <= 0 or amount > self.__balance:
           return False
        else:
           self.__balance -= amount
           return True

    def get_balance(self: Account) -> int:
        """Gets balance."""
        return self.__balance

    def get_name(self: Account) -> object:
        """Gets name."""
        return self.__name

    def set_balance(self: Account, value: float) -> None:
        """Sets balance unless value is negative."""
        if value < 0:
            self.__balance = 0
        else:
            self.__balance = value

    def set_name(self: Account, value: float) -> None:
        """Sets name."""
        self.__name = value

    def __str__(self: Account) -> str:
        """Returns formatted string of account details."""
        return f'Account name = {self.get_name()}, Account balance = {self.get_balance():.2f}'

load_user_info_from_csvfile()
